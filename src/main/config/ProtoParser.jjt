/**
 *  Protocol Buffers v.3 grammar  for JavaCC
 *  Contributed by Toshikazu Ando (foobar@em.boo.jp)
 */

options {
    /* Must not be STATIC, because ProtoParserContext creates parsers for any included files. */
    STATIC=false;
    SANITY_CHECK=true;
    DEBUG_PARSER=false;
    DEBUG_TOKEN_MANAGER=false;
}

PARSER_BEGIN(ProtoParser)
package protongo.parser;

import protongo.compile.TypeFullName;
import java.util.regex.Pattern;

/** Protobuf 3 grammar, with support for collecting limited type information. Purpose: Generate a custom schema.
    When you want to generate a schema for a given "message," add a special (single-line) comment immediately before
    that "message." See handlingInstruction(Token) and how it's used.

    Before you instantiate `new ProtoParser(streamOrOther)`, first create a `new ProtoParserContext()`
    in the same thread. */
public class ProtoParser {
    private static final Pattern HANDLING_INSTRUCTION= Pattern.compile("GENERATE *DB *SCHEMA");

    /** If the given messageToken has a special comment immediately before it, then this extracts its value.
        Otherwise it returns null. */
    private void registerHandlingInstruction(TypeFullName type, Token messageToken) {
        if (messageToken.specialToken!=null) {
            String image = messageToken.specialToken.image;
            if (HANDLING_INSTRUCTION.matcher(image).matches()) {
                HandlingInstruction instruction= new HandlingInstruction();
                context.instructions.put (type, instruction);
            }
        }
    }

    /* More convenient/intuitive than getContext(). Plus, if we didn't have `context` as final, then
       BNF grammar rules could reassign `context` by mistake. */
    final ProtoParserContext context = registerWithContext();

    private ProtoParserContext registerWithContext() {
        // When this method is called, `this` instance if not complete yet. That's OK.
        if (context!=null) {
            throw new IllegalStateException("Parser already has its context set.");
        }
        ProtoParserContext.register (this);
        return ProtoParserContext.perThread();
    }
}

PARSER_END(ProtoParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}


TOKEN :
{
  <CSTRING_TKN: "\"" ( ~["\""] )* "\"" >
| <EQUL_TKN: "=">
| <SEMI_COLON_TKN: ";">
| <COLON_TKN: ":">
| <CONNMA_TKN: ",">
| <DOT_TKN: ".">
| <TO_TKN: "to">
| <LEFTBRACE_TKN: "{">
| <RIGHTBRACE_TKN: "}">
| <LEFTPAREN_TKN: "(">
| <RIGHTPAREN_TKN: ")">
| <LEFTBRACKET_TKN: "[">
| <RIGHTBRACKET_TKN: "]">
| <LESSTHAN_TKN: "<">
| <GRATETHAN_TKN: ">">
| <SYNTAX_TKN: "syntax">
| <BOOLEAN_TKN: "true" | "false">
| <ATTRIBUTE_TKN: "required"
                | "optional">
| <OPTION_TKN: "option">
| <IMPORT_TKN: "import">
| <PUBLIC_TKN: "public">
| <PACKAGE_TKN: "package">
| <SERVICE_TKN: "service">
| <MESSAGE_TKN: "message">
| <ENUM_TKN: "enum">
| <ONEOF_TKN: "oneof">
| <GROUP_TKN: "group">
| <EXTENTIONS_TKN: "extensions">
| <EXTEND_TKN: "extend">
| <MAP_TKN: "map">
| <RESERVED_TKN: "reserved">
| <REPEATED_TKN: "repeated">
| <RETURNS_TKN: "returns">
| <STREAM_TKN: "stream">
| <TYPE_TKN: "double"
           | "float"
           | "int32"
           | "int64"
           | "uint32"
           | "uint64"
           | "sint32"
           | "sint64"
           | "fixed32"
           | "fixed64"
           | "sfixed32"
           | "sfixed64"
           | "bool"
           | "string"
           | "bytes"
           | "Any">
| <RPC_TKN: "rpc">
| <NUMBER_TKN: "0" | (["-"])?["1"-"9"](["0"-"9"])* | "max">
| <DOUBLE_TKN: ("0" | (["-"])?["1"-"9"](["0"-"9"])*) "." (["0"-"9"])*>
| <IDENT_TKN: ["_","a"-"z","A"-"Z"] (["_","a"-"z","A"-"Z","0"-"9"])*>
}

void Input() : {
} {
  (ImportPart()
   | SyntaxPart()
   | OptionPart()
   | PackagePart()
   | ServicePart()
   | MessagePart(null)
   | EnumPart(null)
   | ExtendPart())*
}

void ImportPart() : {
} { 
  <IMPORT_TKN> [PublicPart()] CStringPart() <SEMI_COLON_TKN>
}

void PublicPart() : {
} {
    <PUBLIC_TKN>
}

void ValuePart() : {
} {
  BooleanPart()
   | CStringPart()
   | NumberPart()
   | DoublePart()
   | IndentPart()
   | BraceValuePart()
}
void BooleanPart() : {
} {
    <BOOLEAN_TKN> /* { code...}*/
}
void CStringPart() : { 
} {
    <CSTRING_TKN>
}
void NumberPart() : { 
} {
    <NUMBER_TKN>
}
void DoublePart() : { 
} {
    <DOUBLE_TKN>
}
Token IndentPart() : {
  Token t;
} {
    t=<IDENT_TKN> {return t;}
}
void BraceValuePart() : {
} {
   <LEFTBRACE_TKN>
   (BraceValueOnePart())*
   <RIGHTBRACE_TKN>
}
void BraceValueOnePart() : {
} {
   IndentPart() <COLON_TKN> (BraceValueOneBracketPart() | ValuePart())
}
void BraceValueOneBracketPart() : {
} {
   <LEFTBRACKET_TKN>
   ValuePart() (<CONNMA_TKN> ValuePart())*
   <RIGHTBRACKET_TKN>
}
void SyntaxPart() : {
} { 
   <SYNTAX_TKN> <EQUL_TKN> CStringPart() <SEMI_COLON_TKN>
}
void OptionPart() : {
} {     
    <OPTION_TKN> ClassPartNoCapture() <EQUL_TKN> ValuePart() <SEMI_COLON_TKN>
}

void ClassPartNoCapture() : {
} {
  ClassPart(null, null)
}

/** typeToken indicates what kind of 'type' (e.g. "message", "enum"...) this identifier is for. */
TypeFullName ClassPart(Token typeToken, TypeFullName parent) : {
 TypeFullName type;
 Token t;
} {
  ( t=IndentPart() {type= new TypeFullName(/*typeToken*/parent, t.image);}
  | CustomOptionsPart() {type= parent;}
  )
  (<DOT_TKN> ( t=IndentPart() {type= new TypeFullName(/*typeToken, */type, t.image);}
       | CustomOptionsPart()
       )
  )*
  {return type;}
}
void CustomOptionsPart() : {
} {
   <LEFTPAREN_TKN> ClassPartNoCapture() <RIGHTPAREN_TKN>
}
void KeyPart() : {
} {
   <IDENT_TKN>
    | <MESSAGE_TKN>
    | <PACKAGE_TKN>
    | <SERVICE_TKN>
}

void PackagePart() : {
} { 
  <PACKAGE_TKN> ClassPartNoCapture() <SEMI_COLON_TKN>
}

void ServicePart() : {
} { 
  <SERVICE_TKN> <IDENT_TKN>
   <LEFTBRACE_TKN>
   (OptionPart()
    |RpcPart())*
   <RIGHTBRACE_TKN>
}
void RpcPart() : {
} { 
  <RPC_TKN> ClassPartNoCapture()
   <LEFTPAREN_TKN>
   [(StreamPart())? ClassPartNoCapture()]
   <RIGHTPAREN_TKN>
   <RETURNS_TKN>
   
   <LEFTPAREN_TKN>
   [(StreamPart())? ClassPartNoCapture()]
   <RIGHTPAREN_TKN>
   
   (RpcBracePart()|<SEMI_COLON_TKN>)
}
void StreamPart() : {
} {     
    <STREAM_TKN>
}
void RpcBracePart() : {
} {     
    <LEFTBRACE_TKN>
    (OptionPart())*
    <RIGHTBRACE_TKN>
}

void MessagePart(TypeFullName parent) : {
    Token t;
    TypeFullName type;
} {
  t=<MESSAGE_TKN>
  type=ClassPart(t, parent) MessageBranchePart(type)
  {
    ProtoParserContext.perThread().addType(type);
    registerHandlingInstruction(type, t);
  }
}
void MessageBranchePart(TypeFullName parent) : {
} {
   <LEFTBRACE_TKN>
   (AttributeMemberPart()
    |EnumPart(parent)
    |ReservedPart()
    |OneOfPart()
    |MapPart()
    |MessagePart(parent)
    |ExtentionsPart()
    |ExtendPart()
    |OptionPart()
    |<SEMI_COLON_TKN>)*
   <RIGHTBRACE_TKN>
}
void AttributeMemberPart() : {
} { 
  [AttributePart()][RepeatedPart()]
  (MemberPart()|GroupPart())
}
void MemberPart() : {
} { 
  ClassOrTypePart() KeyPart() <EQUL_TKN> NumberPart() [BracketPart()] <SEMI_COLON_TKN>
}
void AttributePart() : {
} {
    <ATTRIBUTE_TKN>
}
void RepeatedPart() : {
} { 
    <REPEATED_TKN>
}
void GroupPart() : {
} {
  <GROUP_TKN> ClassPartNoCapture() <EQUL_TKN> NumberPart()
  MessageBranchePart(null)
}
void ClassOrTypePart() : {
} {     
  TypePart()
  | ClassPartNoCapture()
}
void TypePart() : {
} {
  <TYPE_TKN>
}
void BracketPart() : {
} {
  <LEFTBRACKET_TKN>
  (BracketMemberPart() (<CONNMA_TKN> BracketMemberPart())*)?
  <RIGHTBRACKET_TKN>
}
void BracketMemberPart() : {} {
  ClassPartNoCapture() <EQUL_TKN> ValuePart()
}

void EnumPart(TypeFullName parent) : {
 Token t;
 TypeFullName type;
} {
  t= <ENUM_TKN>
   type=ClassPart(t, parent)
   <LEFTBRACE_TKN>
   (EnumMemberPart())*
   <RIGHTBRACE_TKN>
   {throw new Error("TODO");}
}
void EnumMemberPart() : {
} { 
  [EnumOptionMemberPart()]
  ClassPartNoCapture() <EQUL_TKN> ValuePart() [BracketPart()] <SEMI_COLON_TKN>
}
void EnumOptionMemberPart() : {
} { 
  <OPTION_TKN>
}

void ReservedPart() : {
} { 
  <RESERVED_TKN> ValuePart() (DeviderPart() ValuePart())* <SEMI_COLON_TKN>
}
void DeviderPart() : {
} {
    <CONNMA_TKN>
    | <TO_TKN>
}

void OneOfPart() : {
} { 
  <ONEOF_TKN>
   ClassPartNoCapture()
   <LEFTBRACE_TKN>
   (MemberPart())*
   <RIGHTBRACE_TKN>
}

void MapPart() : {
} { 

  <MAP_TKN>
  <LESSTHAN_TKN>
   ClassOrTypePart()
   <CONNMA_TKN>
   ClassOrTypePart()
  <GRATETHAN_TKN>
  KeyPart() <EQUL_TKN> NumberPart() <SEMI_COLON_TKN>
}

void ExtentionsPart() : {
} { 

  <EXTENTIONS_TKN> NumberPart() <TO_TKN> NumberPart() <SEMI_COLON_TKN>
}
void ExtendPart() : {
} { 
  <EXTEND_TKN> ClassPartNoCapture() MessageBranchePart(null)
}
/* END */
