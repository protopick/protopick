/**
 *  Protocol Buffers v.3 grammar  for JavaCC
 *  Contributed by Toshikazu Ando (foobar@em.boo.jp)
 */

options {
    /* Must not be STATIC, because ProtoParserContext creates parsers for any included files. */
    STATIC=false;
    SANITY_CHECK=true;
    DEBUG_PARSER=false;
    DEBUG_TOKEN_MANAGER=false;
}

PARSER_BEGIN(ProtoParser)
package protongo.parser;

/** Protobuf 3 grammar, with support for collecting limited type information. Purpose: Generate a custom schema.
    When you want to generate a schema for a given "message," add a special (single-line) comment immediately before
    that "message." See specialCommentInfo().

    Before you instantiate `new ProtoParser(streamOrOther)`, first create a `new ProtoParserContext()`
    in the same thread. */
public class ProtoParser {

    /** If the given messageToken has a special comment immediately before it, then this extracts its value.
        Otherwise it returns null. */
    private static String specialCommentInfo(Token messageToken) {
        if (messageToken.specialToken!=null) {

        }
        return null;
    }

    /* Situation: We're parsing a message. One of its fields refers to another type (a message, enum...).
       That type reference is either:
       1. Unqualified (no dot). That's a name of another type in the same package (in the same or a different file).
       2. Qualified (with a dot or several) type with a package name: name.of.a.package.nameOfType.
       2. Qualified (with a dot or several) sub-message: nameOfAnotherMessage.nameOfItsInnerMessage...
       where nameOfAnotherMessage may contain a package name or not.
       If that other type is in the same file, we don't want to start parsing it right now. We've either already
       parsed it, or we will parse it later, in this same ProtoParser instance.
       Hence, BNF rules only register Type instances with ProtoParserContext. But they're validated and "compiled" later.
    */

    /* More convenient/intuitive than getContext(). Plus, if we didn't have `context` as final, then
       BNF grammar rules could reassign `context` by mistake. */
    final ProtoParserContext context = registerWithContext();

    private ProtoParserContext registerWithContext() {
        // When this method is called, `this` instance if not complete yet. That's OK.
        if (context!=null) {
            throw new IllegalStateException("Parser already has its context set.");
        }
        ProtoParserContext.register (this);
        return ProtoParserContext.perThread();
    }
}

PARSER_END(ProtoParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}


TOKEN :
{
  <CSTRING_TKN: "\"" ( ~["\""] )* "\"" >
| <EQUL_TKN: "=">
| <SEMI_COLON_TKN: ";">
| <COLON_TKN: ":">
| <CONNMA_TKN: ",">
| <DOT_TKN: ".">
| <TO_TKN: "to">
| <LEFTBRACE_TKN: "{">
| <RIGHTBRACE_TKN: "}">
| <LEFTPAREN_TKN: "(">
| <RIGHTPAREN_TKN: ")">
| <LEFTBRACKET_TKN: "[">
| <RIGHTBRACKET_TKN: "]">
| <LESSTHAN_TKN: "<">
| <GRATETHAN_TKN: ">">
| <SYNTAX_TKN: "syntax">
| <BOOLEAN_TKN: "true" | "false">
| <ATTRIBUTE_TKN: "required"
                | "optional">
| <OPTION_TKN: "option">
| <IMPORT_TKN: "import">
| <PUBLIC_TKN: "public">
| <PACKAGE_TKN: "package">
| <SERVICE_TKN: "service">
| <MESSAGE_TKN: "message">
| <ENUM_TKN: "enum">
| <ONEOF_TKN: "oneof">
| <GROUP_TKN: "group">
| <EXTENTIONS_TKN: "extensions">
| <EXTEND_TKN: "extend">
| <MAP_TKN: "map">
| <RESERVED_TKN: "reserved">
| <REPEATED_TKN: "repeated">
| <RETURNS_TKN: "returns">
| <STREAM_TKN: "stream">
| <TYPE_TKN: "double"
           | "float"
           | "int32"
           | "int64"
           | "uint32"
           | "uint64"
           | "sint32"
           | "sint64"
           | "fixed32"
           | "fixed64"
           | "sfixed32"
           | "sfixed64"
           | "bool"
           | "string"
           | "bytes"
           | "Any">
| <RPC_TKN: "rpc">
| <NUMBER_TKN: "0" | (["-"])?["1"-"9"](["0"-"9"])* | "max">
| <DOUBLE_TKN: ("0" | (["-"])?["1"-"9"](["0"-"9"])*) "." (["0"-"9"])*>
| <IDENT_TKN: ["_","a"-"z","A"-"Z"] (["_","a"-"z","A"-"Z","0"-"9"])*>
}

void Input() : {
} {
  (ImportPart()
   | SyntaxPart()
   | OptionPart()
   | PackagePart()
   | ServicePart()
   | MessagePart()
   | EnumPart()
   | ExtendPart())*
}

void ImportPart() : {
} { 
  <IMPORT_TKN> [PublicPart()] CStringPart() <SEMI_COLON_TKN>
}

void PublicPart() : {
} {
    <PUBLIC_TKN>
}

void ValuePart() : {
} {
  BooleanPart()
   | CStringPart()
   | NumberPart()
   | DoublePart()
   | IndentPart()
   | BraceValuePart()
}
void BooleanPart() : {
} {
    <BOOLEAN_TKN> /* { code...}*/
}
void CStringPart() : { 
} {
    <CSTRING_TKN>
}
void NumberPart() : { 
} {
    <NUMBER_TKN>
}
void DoublePart() : { 
} {
    <DOUBLE_TKN>
}
void IndentPart() : {
} {
    <IDENT_TKN>
}
void BraceValuePart() : {
} {
   <LEFTBRACE_TKN>
   (BraceValueOnePart())*
   <RIGHTBRACE_TKN>
}
void BraceValueOnePart() : {
} {
   IndentPart() <COLON_TKN> (BraceValueOneBracketPart() | ValuePart())
}
void BraceValueOneBracketPart() : {
} {
   <LEFTBRACKET_TKN>
   ValuePart() (<CONNMA_TKN> ValuePart())*
   <RIGHTBRACKET_TKN>
}
void SyntaxPart() : {
} { 
   <SYNTAX_TKN> <EQUL_TKN> CStringPart() <SEMI_COLON_TKN>
}
void OptionPart() : {
} {     
    <OPTION_TKN> ClassPart() <EQUL_TKN> ValuePart() <SEMI_COLON_TKN>
}
void ClassPart() : {
} {
  (IndentPart()|CustomOptionsPart()) (<DOT_TKN> (IndentPart()|CustomOptionsPart()))*
}
void CustomOptionsPart() : {
} {
   <LEFTPAREN_TKN> ClassPart() <RIGHTPAREN_TKN>
}
void KeyPart() : {
} {
   <IDENT_TKN>
    | <MESSAGE_TKN>
    | <PACKAGE_TKN>
    | <SERVICE_TKN>
}

void PackagePart() : {
} { 
  <PACKAGE_TKN> ClassPart() <SEMI_COLON_TKN>
}

void ServicePart() : {
} { 
  <SERVICE_TKN> <IDENT_TKN>
   <LEFTBRACE_TKN>
   (OptionPart()
    |RpcPart())*
   <RIGHTBRACE_TKN>
}
void RpcPart() : {
} { 
  <RPC_TKN> ClassPart()
   <LEFTPAREN_TKN>
   [(StreamPart())? ClassPart()]
   <RIGHTPAREN_TKN>
   <RETURNS_TKN>
   
   <LEFTPAREN_TKN>
   [(StreamPart())? ClassPart()]
   <RIGHTPAREN_TKN>
   
   (RpcBracePart()|<SEMI_COLON_TKN>)
}
void StreamPart() : {
} {     
    <STREAM_TKN>
}
void RpcBracePart() : {
} {     
    <LEFTBRACE_TKN>
    (OptionPart())*
    <RIGHTBRACE_TKN>
}

void MessagePart() : {
    Token mt;
} { 
  mt=<MESSAGE_TKN>
  {
    String special= specialCommentInfo(mt);
  }
  ClassPart() MessageBranchePart(special)
}
void MessageBranchePart(String special) : {
    boolean isMessage = false;
} {
   <LEFTBRACE_TKN>
   (AttributeMemberPart()
    |EnumPart()
    |ReservedPart()
    |OneOfPart()
    |MapPart()
    |MessagePart() { isMessage = true; }
    |ExtentionsPart()
    |ExtendPart()
    |OptionPart()
    |<SEMI_COLON_TKN>)*
   <RIGHTBRACE_TKN>
   {if (!isMessage) throw new IllegalStateException("Special comment (" +special+ " can be used for a 'message' only."); }
}
void AttributeMemberPart() : {
} { 
  [AttributePart()][RepeatedPart()]
  (MemberPart()|GroupPart())
}
void MemberPart() : {
} { 
  ClassOrTypePart() KeyPart() <EQUL_TKN> NumberPart() [BracketPart()] <SEMI_COLON_TKN>
}
void AttributePart() : {
} {
    <ATTRIBUTE_TKN>
}
void RepeatedPart() : {
} { 
    <REPEATED_TKN>
}
void GroupPart() : {
} {
  <GROUP_TKN> ClassPart() <EQUL_TKN> NumberPart()
  MessageBranchePart(null)
}
void ClassOrTypePart() : {
} {     
  TypePart()
  | ClassPart()
}
void TypePart() : {
} {
  <TYPE_TKN>
}
void BracketPart() : {
} { 
  <LEFTBRACKET_TKN>
  (BracketMemberPart() (<CONNMA_TKN> BracketMemberPart())*)?
  <RIGHTBRACKET_TKN>
}
void BracketMemberPart() : {
} { 
  ClassPart() <EQUL_TKN> ValuePart()
}

void EnumPart() : {
} { 
  <ENUM_TKN>
   ClassPart()
   <LEFTBRACE_TKN>
   (EnumMemberPart())*
   <RIGHTBRACE_TKN>
}
void EnumMemberPart() : {
} { 
  [EnumOptionMemberPart()]
  ClassPart() <EQUL_TKN> ValuePart() [BracketPart()] <SEMI_COLON_TKN>
}
void EnumOptionMemberPart() : {
} { 
  <OPTION_TKN>
}

void ReservedPart() : {
} { 
  <RESERVED_TKN> ValuePart() (DeviderPart() ValuePart())* <SEMI_COLON_TKN>
}
void DeviderPart() : {
} {
    <CONNMA_TKN>
    | <TO_TKN>
}

void OneOfPart() : {
} { 
  <ONEOF_TKN>
   ClassPart()
   <LEFTBRACE_TKN>
   (MemberPart())*
   <RIGHTBRACE_TKN>
}

void MapPart() : {
} { 

  <MAP_TKN>
  <LESSTHAN_TKN>
   ClassOrTypePart()
   <CONNMA_TKN>
   ClassOrTypePart()
  <GRATETHAN_TKN>
  KeyPart() <EQUL_TKN> NumberPart() <SEMI_COLON_TKN>
}

void ExtentionsPart() : {
} { 

  <EXTENTIONS_TKN> NumberPart() <TO_TKN> NumberPart() <SEMI_COLON_TKN>
}
void ExtendPart() : {
} { 
  <EXTEND_TKN> ClassPart() MessageBranchePart(null)
}
/* END */
